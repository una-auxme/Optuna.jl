var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Storage","page":"API Reference","title":"Storage","text":"","category":"section"},{"location":"api/#Journal","page":"API Reference","title":"Journal","text":"","category":"section"},{"location":"api/#Artifacts","page":"API Reference","title":"Artifacts","text":"","category":"section"},{"location":"api/#Sampler","page":"API Reference","title":"Sampler","text":"","category":"section"},{"location":"api/#Pruner","page":"API Reference","title":"Pruner","text":"","category":"section"},{"location":"api/#Crossover","page":"API Reference","title":"Crossover","text":"","category":"section"},{"location":"api/#Study","page":"API Reference","title":"Study","text":"","category":"section"},{"location":"api/#Trial","page":"API Reference","title":"Trial","text":"","category":"section"},{"location":"api/#Optimization","page":"API Reference","title":"Optimization","text":"","category":"section"},{"location":"api/#Utils","page":"API Reference","title":"Utils","text":"","category":"section"},{"location":"api/#Optuna.RDBStorage","page":"API Reference","title":"Optuna.RDBStorage","text":"RDBStorage(\n    url::String\n)\n\nStorage class for RDB backends. For further information see the RDBStorage in the Optuna python documentation.\n\nArguments\n\nurl::String: URL of the database (e.g. directory and filename for SQLite).\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.InMemoryStorage","page":"API Reference","title":"Optuna.InMemoryStorage","text":"InMemoryStorage()\n\nStorage class that stores data in memory of the running process. For further information see the InMemoryStorage in the Optuna python documentation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.JournalStorage","page":"API Reference","title":"Optuna.JournalStorage","text":"JournalStorage(\n    backend::BaseJournalBackend\n)\n\nStorage class for Journal storage backend. For further information see the JournalStorage in the Optuna python documentation.\n\nArguments\n\nbackend::BaseJournalBackend: Backend that determines where the data is stored.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.get_all_study_names","page":"API Reference","title":"Optuna.get_all_study_names","text":"get_all_study_names(\n    storage::BaseStorage\n)\n\nReturns all study names stored in the given storage. For further information see the getallstudy_names in the Optuna python documentation.\n\nArguments\n\nstorage::BaseStorage: Storage backend to query.\n\nReturns\n\nVector{String}: List of study names.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.create_sqlite_url","page":"API Reference","title":"Optuna.create_sqlite_url","text":"create_sqlite_url(\n    database_path::String, \n    database_name::String\n)\n\nReturns a valid URL for a SQLite database with the given arguments.\n\nArguments\n\ndatabase_path::String: Path to the directory where the database is stored.\ndatabase_name::String: Name of the database file.\n\nReturns\n\nString: URL for the SQLite database.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.create_mysql_url","page":"API Reference","title":"Optuna.create_mysql_url","text":"create_mysql_url(;\n    user_name::String=\"\",\n    password::String=\"\",\n    host::String=\"\",\n    port::String=\"\",\n    database_name::String=\"\",\n    query::Dict{String,Any}=Dict{String,Any}(),\n\n)\n\nReturns a valid URL for a MySQL database with the given arguments.\n\nKeyword Arguments\n\nuser_name::String=\"\": Name of the database user.\npassword::String=\"\": Password of the database user.\nhost::String=\"\": Host where the database server is running.\nport::String=\"\": Port of the database server.\ndatabase_name::String=\"\": Name of the database.\nquery::Dict{String,Any}=Dict{String,Any}(): Query string with keys and either strings or additional query strings as values.\n\nReturns\n\nString: URL to the MySQL database.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.create_redis_url","page":"API Reference","title":"Optuna.create_redis_url","text":"create_redis_url(;\n    user_name::String=\"\",\n    password::String=\"\",\n    host::String=\"\",\n    port::String=\"6379\",\n    database_index::String=\"0\",\n\n) Returns a valid URL for a Redis server with the given arguments.\n\nKeyword Arguments\n\nuser_name::String=\"\": Name of the Redis user.\npassword::String=\"\": Password of the Redis user.\nhost::String=\"\": Host where the Redis server is running.\nport::String=\"6379\": Port of the Redis server.\ndatabase_index::String=\"0\": Index of the database.\n\nReturns\n\nString: URL to the Redis database.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.JournalFileBackend","page":"API Reference","title":"Optuna.JournalFileBackend","text":"JournalFileBackend(\n    file_path::String; \n    lock_obj::Union{Nothing,BaseJournalFileLock}=nothing\n)\n\nFile storage class for Journal log backend. For further information see the JournalFileBackend in the Optuna python documentation.\n\nArguments\n\nfile_path::String: Path of file to persist the log to.\n\nKeyword Arguments\n\nlock_obj::Union{Nothing,BaseJournalFileLock}=nothing: Lock object for process exclusivity. An instance of JournalFileSymlinkLock and JournalFileOpenLock can be passed.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.JournalRedisBackend","page":"API Reference","title":"Optuna.JournalRedisBackend","text":"JournalRedisBackend(\n    url::String, \n    use_cluster::Bool=false, \n    prefix::String=\"\"\n)\n\nRedis storage class for Journal log backend. For further information see the JournalRedisBackend in the Optuna python documentation.\n\nArguments\n\nurl::String: URL of the redis storage.\nuse_cluster::Bool=false: Flag whether you use the Redis cluster.\nprefix::String=\"\": Prefix of the preserved key of logs. This is useful when multiple users work on one Redis server.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.JournalFileSymlinkLock","page":"API Reference","title":"Optuna.JournalFileSymlinkLock","text":"JournalFileSymlinkLock(\n    file_path::String, \n    grace_period::Union{Nothing,Int}=30\n)\n\nLock class for synchronizing processes for NFSv2 or later. For further information see the JournalFileSymlinkLock in the Optuna python documentation.\n\nArguments\n\nfile_path::String: The path of the file whose race condition must be protected.\ngrace_period::Union{Nothing,Int}=30: Grace period before an existing lock is forcibly released.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.JournalFileOpenLock","page":"API Reference","title":"Optuna.JournalFileOpenLock","text":"JournalFileOpenLock(\n    file_path::String, \n    grace_period::Union{Nothing,Int}=30}\n)\n\nLock class for synchronizing processes for NFSv3 or later. For further information see the JournalFileOpenLock in the Optuna python documentation.\n\nArguments\n\nfile_path::String: The path of the file whose race condition must be protected.\ngrace_period::Union{Nothing,Int}=30: Grace period before an existing lock is forcibly released.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.FileSystemArtifactStore","page":"API Reference","title":"Optuna.FileSystemArtifactStore","text":"FileSystemArtifactStore(\n    path::String\n)\n\nData structure for a file system based artifact store. For further information see the FileSystemArtifactStore in the Optuna python documentation.\n\nArguments\n\npath::String: Path to the directory where artifacts are stored.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.ArtifactMeta","page":"API Reference","title":"Optuna.ArtifactMeta","text":"ArtifactMeta\n\nData structure containing metadata for an artifact. For further information see the ArtifactMeta in the Optuna python documentation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.RandomSampler","page":"API Reference","title":"Optuna.RandomSampler","text":"RandomSampler(seed=nothing::Union{Nothing,Integer})\n\nAn independent sampler that samples randomly. For further information see the RandomSampler in the Optuna python documentation.\n\nArguments\n\nseed::Union{Nothing,Integer}=nothing: Seed for the random number generator.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.TPESampler","page":"API Reference","title":"Optuna.TPESampler","text":"TPESampler(;\n    consider_prior::Bool=true,\n    prior_weight::Float64=1.0,\n    consider_magic_clip::Bool=true,\n    consider_endpoints::Bool=false,\n    n_startup_trials::Integer=10,\n    n_ei_candidates::Integer=24,\n    gamma::Union{Nothing,Function}=nothing,\n    weights::Union{Nothing,Function}=nothing,\n    seed::Union{Nothing,Integer}=nothing,\n    multivariate::Bool=false,\n    group::Bool=false,\n    warn_independent_sampling::Bool=true,\n    constant_liar::Bool=false,\n    constraints_func::Union{Nothing,Function}=nothing,\n    categorical_distance_func::Union{Nothing,Function}=nothing,\n)\n\nSampler using TPE (Tree-structured Parzen Estimator) algorithm. For further information see the TPESampler in the Optuna python documentation.\n\nKeyword Arguments\n\nconsider_prior::Bool=true: Enhance the stability of Parzen estimator by imposing a Gaussian prior when true. The prior is only effective if the sampling distribution is either FloatDistribution, or IntDistribution. Deprecated in v4.3.0. Will be removed in v6.0.0.\nprior_weight::Float64=1.0: The weight of the prior. This argument is used in FloatDistribution, IntDistribution, and CategoricalDistribution.\nconsider_magic_clip::Bool=true: Enable a heuristic to limit the smallest variances of Gaussians used in the Parzen estimator.\nconsider_endpoints::Bool=false: Take endpoints of domains into account when calculating variances of Gaussians in Parzen estimator. See the original paper for details on the heuristics to calculate the variances.\nn_startup_trials::Integer=10: The random sampling is used instead of the TPE algorithm until the given number of trials finish in the same study.\nn_ei_candidates::Integer=24: Number of candidate samples used to calculate the expected improvement.\ngamma::Union{Nothing,Function}=nothing: A function that takes the number of finished trials and returns the number of trials to form a density function for samples with low grains. See the original paper for more details.\nweights::Union{Nothing,Function}=nothing: A function that takes the number of finished trials and returns a weight for them. See Making a Science of Model Search: Hyperparameter Optimization in Hundreds of Dimensions for Vision Architectures for more details.\nseed::Union{Nothing,Integer}=nothing: Seed for random number generator.\nmultivariate::Bool=false: If this is true, the multivariate TPE is used when suggesting parameters. The multivariate TPE is reported to outperform the independent TPE. See BOHB: Robust and Efficient Hyperparameter Optimization at Scale and the article of the Optuna dev team for more details.\ngroup::Bool=false: If this and multivariate are true, the multivariate TPE with the group decomposed search space is used when suggesting parameters. The sampling algorithm decomposes the search space based on past trials and samples from the joint distribution in each decomposed subspace. The decomposed subspaces are a partition of the whole search space. Each subspace is a maximal subset of the whole search space, which satisfies the following: for a trial in completed trials, the intersection of the subspace and the search space of the trial becomes subspace itself or an empty set. Sampling from the joint distribution on the subspace is realized by multivariate TPE. If group is true, multivariate must be true as well.\nwarn_independent_sampling::Bool=true: If this is true and multivariate=true, a warning message is emitted when the value of a parameter is sampled by using an independent sampler. If multivariate=false, this flag has no effect.\nconstant_liar::Bool=false: If true, penalize running trials to avoid suggesting parameter configurations nearby.\nconstraints_func::Union{Nothing,Function}=nothing: An optional function that computes the objective constraints. It must take a FrozenTrial and return the constraints. The return value must be a sequence of floats. A value strictly larger than 0 means that a constraints is violated. A value equal to or smaller than 0 is considered feasible. If constraintsfunc returns more than one value for a trial, that trial is considered feasible if and only if all values are equal to 0 or smaller. The constraintsfunc will be evaluated after each successful trial. The function won’t be called when trials fail or they are pruned, but this behavior is subject to change in the future releases.\ncategorical_distance_func::Union{Nothing,Function}=nothing: A dictionary of distance functions for categorical parameters. The key is the name of the categorical parameter and the value is a distance function that takes two CategoricalChoiceTypes and returns a float value. The distance function must return a non-negative value. While categorical choices are handled equally by default, this option allows users to specify prior knowledge on the structure of categorical parameters. When specified, categorical choices closer to current best choices are more likely to be sampled.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.GPSampler","page":"API Reference","title":"Optuna.GPSampler","text":"GPSampler(;\n    seed::Union{Nothing,Integer}=nothing,\n    independent_sampler::Union{Nothing,BaseSampler}=nothing,\n    n_startup_trials::Integer=10,\n    deterministic_objective::Bool=false,\n    constraints_func::Union{Nothing,Function}=nothing,\n    warn_independent_sampling::Bool=true,\n)\n\nSampler using Gaussian process-based Bayesian optimization. For further information see the GPSampler in the Optuna python documentation.\n\nKeyword Arguments\n\nseed::Union{Nothing,Integer}=nothing: Random seed to initialize internal random number generator. Defaults to nothing (a seed is picked randomly).\nindependent_sampler::Union{Nothing,BaseSampler}=nothing: Sampler used for initial sampling (for the first n_startup_trials trials) and for conditional parameters. Defaults to nothing (a random sampler with the same seed is used).\nn_startup_trials::Integer=10: Number of initial trials.\ndeterministic_objective::Bool=false: Whether the objective function is deterministic or not. If true, the sampler will fix the noise variance of the surrogate model to the minimum value (slightly above 0 to ensure numerical stability). Defaults to false. Currently, all the objectives will be assume to be deterministic if true.\nconstraints_func::Union{Nothing,Function}=nothing: An optional function that computes the objective constraints. It must take a FrozenTrial and return the constraints. The return value must be a sequence of floats. A value strictly larger than 0 means that a constraints is violated. A value equal to or smaller than 0 is considered feasible. If constraints_func returns more than one value for a trial, that trial is considered feasible if and only if all values are equal to 0 or smaller.\nwarn_independent_sampling::Bool=true:  If this is true, a warning message is emitted when the value of a parameter is sampled by using an independent sampler, meaning that no GP model is used in the sampling. Note that the parameters of the first trial in a study are always sampled via an independent sampler, so no warning messages are emitted in this case.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.CmaEsSampler","page":"API Reference","title":"Optuna.CmaEsSampler","text":"CmaEsSampler(\n    x0::Union{Nothing,Dict{String,Any}}=nothing,\n    sigma0::Union{Nothing,Float64}=nothing,\n    n_startup_trials::Int=1,\n    independent_sampler::Union{Nothing,BaseSampler}=nothing,\n    warn_independent_sampling::Bool=true,\n    seed::Union{Nothing,Integer}=nothing;\n    consider_pruned_trials::Bool=false,\n    restart_strategy::Union{Nothing,String}=nothing,\n    popsize::Union{Nothing,Integer}=nothing,\n    inc_popsize::Int=-1,\n    use_separable_cma::Bool=false,\n    with_margin::Bool=false,\n    lr_adapt::Bool=false,\n    source_trials::Union{Nothing,Vector{Trial}}=nothing,\n)\n\nA sampler using cmaes as the backend. For further information see the CmaEsSampler in the Optuna python documentation.\n\nArguments\n\nx0::Union{Nothing,Dict{String,Any}}=nothing: A dictionary of an initial parameter values for CMA-ES. By default, the mean of low and high for each distribution is used. Note that x0 is sampled uniformly within the search space domain for each restart if you specify restart_strategy argument.\nsigma0::Union{Nothing,Float64}=nothing: Initial standard deviation of CMA-ES. By default, sigma0 is set to minrange / 6, where minrange denotes the minimum range of the distributions in the search space.   \nn_startup_trials::Int=1: The independent sampling is used instead of the CMA-ES algorithm until the given number of trials finish in the same study.\nindependent_sampler::Union{Nothing,BaseSampler}=nothing: A BaseSampler instance that is used for independent sampling. The parameters not contained in the relative search space are sampled by this sampler. The search space for CmaEsSampler is determined by intersection_search_space(). If nothing is specified, RandomSampler is used as the default.\nwarn_independent_sampling::Bool=true: If this is true, a warning message is emitted when the value of a parameter is sampled by using an independent sampler. Note that the parameters of the first trial in a study are always sampled via an independent sampler, so no warning messages are emitted in this case.\nseed::Union{Nothing,Integer}=nothing: A random seed for CMA-ES.\n\nKeyword Arguments\n\nconsider_pruned_trials::Bool=false: If this is true, the PRUNED trials are considered for sampling.\nrestart_strategy::Union{Nothing,String}=nothing: Strategy for restarting CMA-ES optimization when converges to a local minimum. If nothing is given, CMA-ES will not restart (default). If ipop is given, CMA-ES will restart with increasing population size. if bipop is given, CMA-ES will restart with the population size increased or decreased. Please see also inc_popsize parameter. Deprecated in v4.4.0. Will be removed in v6.0.0.\npopsize::Union{Nothing,Integer}=nothing: A population size of CMA-ES.\ninc_popsize::Int=-1: Multiplier for increasing population size before each restart. This argument will be used when restart_strategy = 'ipop' or restart_strategy = 'bipop' is specified. Deprecated in v4.4.0. Will be removed in v6.0.0.\nuse_separable_cma::Bool=false: If this is true, the covariance matrix is constrained to be diagonal. Due to reduce the model complexity, the learning rate for the covariance matrix is increased. Consequently, this algorithm outperforms CMA-ES on separable functions.\nwith_margin::Bool=false: If this is true, CMA-ES with margin is used. This algorithm prevents samples in each discrete distribution (FloatDistribution with step and IntDistribution) from being fixed to a single point. Currently, this option cannot be used with use_separable_cma=true.\nlr_adapt::Bool=false: If this is true, CMA-ES with learning rate adaptation is used. This algorithm focuses on working well on multimodal and/or noisy problems with default settings. Currently, this option cannot be used with use_separable_cma=true or with_margin=true.\nsource_trials::Union{Nothing,Vector{Trial}}=nothing: This option is for Warm Starting CMA-ES, a method to transfer prior knowledge on similar HPO tasks through the initialization of CMA-ES. This method estimates a promising distribution from sourcetrials and generates the parameter of multivariate gaussian distribution. Please note that it is prohibited to use x0, sigma0, or `useseparable_cma` argument together.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.NSGAIISampler","page":"API Reference","title":"Optuna.NSGAIISampler","text":"NSGAIISampler(;\n    population_size::Int=50,\n    mutation_prob::Union{Nothing,Float64}=nothing,\n    crossover::Union{Nothing,BaseCrossover}=nothing,\n    crossover_prob::Float64=0.9,\n    swapping_prob::Float64=0.5,\n    seed::Union{Nothing,Integer}=nothing,\n    constraints_func::Union{Nothing,Function}=nothing,\n    elite_population_selection_strategy::Union{Nothing,Function}=nothing,\n    child_generation_strategy::Union{Nothing,Function}=nothing,\n    after_trial_strategy::Union{Nothing,Function}=nothing,\n)\n\nMulti-objective sampler using the NSGA-II algorithm. For further information see the NSGAIISampler in the Optuna python documentation.\n\nKeyword Arguments\n\npopulation_size::Int=50: Number of individuals (trials) in a generation. population_size must be greater than or equal to crossover.n_parents. For UNDXCrossover and SPXCrossover, n_parents=3, and for the other algorithms, n_parents=2.\nmutation_prob::Union{Nothing,Float64}=nothing: Probability of mutating each parameter when creating a new individual. If nothing is specified, the value 1.0 / len(parenttrial.params) is used where `parenttrial` is the parent trial of the target individual.\ncrossover::Union{Nothing,BaseCrossover}=nothing: Crossover to be applied when creating child individuals. The available crossovers are listed here. UniformCrossover is always applied to parameters sampled from CategoricalDistribution, and by default for parameters sampled from other distributions unless this argument is specified. For more information on each of the crossover method, please refer to specific crossover documentation.\ncrossover_prob::Float64=0.9: Probability that a crossover (parameters swapping between parents) will occur when creating a new individual.\nswapping_prob::Float64=0.5: Probability of swapping each parameter of the parents during crossover.\nseed::Union{Nothing,Integer}=nothing: Seed for random number generator.\nconstraints_func::Union{Nothing,Function}=nothing: An optional function that computes the objective constraints. It must take a FrozenTrial and return the constraints. The return value must be a sequence of floats. A value strictly larger than 0 means that a constraints is violated. A value equal to or smaller than 0 is considered feasible. If constraints_func returns more than one value for a trial, that trial is considered feasible if and only if all values are equal to 0 or smaller. The constraints_func will be evaluated after each successful trial. The function won’t be called when trials fail or they are pruned, but this behavior is subject to change in the future releases.                                                               The constraints are handled by the constrained domination. A trial x is said to constrained-dominate a trial y, if any of the following conditions is true:                                                                       Trial x is feasible and trial y is not.                                                                       Trial x and y are both infeasible, but trial x has a smaller overall violation.                                                                       Trial x and y are feasible and trial x dominates trial y.\nelite_population_selection_strategy::Union{Nothing,Function}=nothing: The selection strategy for determining the individuals to survive from the current population pool. Default to nothing.\nchild_generation_strategy::Union{Nothing,Function}=nothing: The strategy for generating child parameters from parent trials. Defaults to nothing.\nafter_trial_strategy::Union{Nothing,Function}=nothing: A set of procedure to be conducted after each trial. Defaults to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.NSGAIIISampler","page":"API Reference","title":"Optuna.NSGAIIISampler","text":"NSGAIIISampler(;\n    population_size::Int=50,\n    mutation_prob::Union{Nothing,Float64}=nothing,\n    crossover::Union{Nothing,BaseCrossover}=nothing,\n    crossover_prob::Float64=0.9,\n    swapping_prob::Float64=0.5,\n    seed::Union{Nothing,Integer}=nothing,\n    constraints_func::Union{Nothing,Function}=nothing,\n    reference_points::Union{Nothing,AbstractArray{T,2}}=nothing,\n    dividing_parameter::Int=3,\n    elite_population_selection_strategy::Union{Nothing,Function}=nothing,\n    child_generation_strategy::Union{Nothing,Function}=nothing,\n    after_trial_strategy::Union{Nothing,Function}=nothing,\n) where {T}\n\nMulti-objective sampler using the NSGA-III algorithm. For further information see the NSGAIIISampler in the Optuna python documentation.\n\nKeyword Arguments\n\npopulation_size::Int=50: Number of individuals (trials) in a generation. population_size must be greater than or equal to crossover.n_parents. For UNDXCrossover and SPXCrossover, n_parents=3, and for the other algorithms, n_parents=2.\nmutation_prob::Union{Nothing,Float64}=nothing: Probability of mutating each parameter when creating a new individual. If nothing is specified, the value 1.0 / len(parenttrial.params) is used where `parenttrial` is the parent trial of the target individual.\ncrossover::Union{Nothing,BaseCrossover}=nothing: Crossover to be applied when creating child individuals. The available crossovers are listed here. UniformCrossover is always applied to parameters sampled from CategoricalDistribution, and by default for parameters sampled from other distributions unless this argument is specified. For more information on each of the crossover method, please refer to specific crossover documentation.\ncrossover_prob::Float64=0.9: Probability that a crossover (parameters swapping between parents) will occur when creating a new individual.\nswapping_prob::Float64=0.5: Probability of swapping each parameter of the parents during crossover.\nseed::Union{Nothing,Integer}=nothing: Seed for random number generator.\nconstraints_func::Union{Nothing,Function}=nothing: An optional function that computes the objective constraints. It must take a FrozenTrial and return the constraints. The return value must be a sequence of floats. A value strictly larger than 0 means that a constraints is violated. A value equal to or smaller than 0 is considered feasible. If constraints_func returns more than one value for a trial, that trial is considered feasible if and only if all values are equal to 0 or smaller. The constraints_func will be evaluated after each successful trial. The function won’t be called when trials fail or they are pruned, but this behavior is subject to change in the future releases.                                                               The constraints are handled by the constrained domination. A trial x is said to constrained-dominate a trial y, if any of the following conditions is true:                                                                       Trial x is feasible and trial y is not.                                                                       Trial x and y are both infeasible, but trial x has a smaller overall violation.                                                                       Trial x and y are feasible and trial x dominates trial y.\nreference_points::Union{Nothing,AbstractArray{T,2}}=nothing: A 2 dimension array with objective dimension columns. Represents a list of reference points which is used to determine who to survive. After non-dominated sort, who out of borderline front are going to survived is determined according to how sparse the closest reference point of each individual is. In the default setting the algorithm uses uniformly spread points to diversify the result. It is also possible to reflect your preferences by giving an arbitrary set of target points since the algorithm prioritizes individuals around reference points.\ndividing_parameter::Int=3: A parameter to determine the density of default reference points. This parameter determines how many divisions are made between reference points on each axis. The smaller this value is, the less reference points you have. The default value is 3. Note that this parameter is not used when reference_points is not nothing.\nelite_population_selection_strategy::Union{Nothing,Function}=nothing: The selection strategy for determining the individuals to survive from the current population pool. Default to nothing.\nchild_generation_strategy::Union{Nothing,Function}=nothing: The strategy for generating child parameters from parent trials. Defaults to nothing.\nafter_trial_strategy::Union{Nothing,Function}=nothing: A set of procedure to be conducted after each trial. Defaults to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.GridSampler","page":"API Reference","title":"Optuna.GridSampler","text":"GridSampler(\n    search_space::Dict{String,Vector}, \n    seed::Union{Nothing,Integer}=nothing\n)\n\nSampler using grid search. For further information see the GridSampler in the Optuna python documentation.\n\nArguments\n\nsearch_space::Dict{String, Vector}: A dictionary whose key and value are a parameter name and the corresponding candidates of values, respectively.\nseed::Union{Nothing,Integer}=nothing: A seed to fix the order of trials as the grid is randomly shuffled. This shuffle is beneficial when the number of grids is larger than n_trials in optimize() to suppress suggesting similar grids. Please note that fixing seed for each process is strongly recommended in distributed optimization to avoid duplicated suggestions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.QMCSampler","page":"API Reference","title":"Optuna.QMCSampler","text":"QMCSampler(;\n    qmc_type::String=\"sobol\",\n    scramble::Bool=false,\n    seed::Union{Nothing,Integer}=nothing,\n    independent_sampler::Union{Nothing,BaseSampler}=nothing,\n    warn_asynchronous_seeding::Bool=true,\n    warn_independent_sampling::Bool=true,\n)\n\nA Quasi Monte Carlo Sampler that generates low-discrepancy sequences. For further information see the QMCSampler in the Optuna python documentation.\n\nKeyword Arguments\n\nqmc_type::String=\"sobol\": The type of QMC sequence to be sampled. This must be one of “halton” and “sobol”. Default is “sobol”.\nscramble::Bool=false: If this option is true, scrambling (randomization) is applied to the QMC sequences.\nseed::Union{Nothing,Integer}: A seed for QMCSampler. This argument is used only when scramble is true. If this is nothing, the seed is initialized randomly. Default is nothing.\nindependent_sampler::Union{Nothing,BaseSampler}=nothing: A BaseSampler instance that is used for independent sampling. The first trial of the study and the parameters not contained in the relative search space are sampled by this sampler. If nothing is specified, RandomSampler is used as the default.\nwarn_asynchronous_seeding::Bool=true: If this is true, a warning message is emitted when the scrambling (randomization) is applied to the QMC sequence and the random seed of the sampler is not set manually.\nwarn_independent_sampling::Bool=true: If this is true, a warning message is emitted when the value of a parameter is sampled by using an independent sampler. Note that the parameters of the first trial in a study are sampled via an independent sampler in most cases, so no warning messages are emitted in such cases.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.BruteForceSampler","page":"API Reference","title":"Optuna.BruteForceSampler","text":"BruteForceSampler(\n    seed::Union{Nothing,Integer}=nothing, \n    avoid_premature_stop::Bool=false\n)\n\nSampler using brute force. This sampler performs exhaustive search on the defined search space. For further information see the BruteForceSampler in the Optuna python documentation.\n\nArguments\n\nseed::Union{Nothing,Integer}=nothing: A seed to fix the order of trials as the search order randomly shuffled. Please note that it is not recommended using this option in distributed optimization settings since this option cannot ensure the order of trials and may increase the number of duplicate suggestions during distributed optimization.\navoid_premature_stop::Bool=false:If true, the sampler performs a strict exhaustive search. Please note that enabling this option may increase the likelihood of duplicate sampling. When this option is not enabled (default), the sampler applies a looser criterion for determining when to stop the search, which may result in incomplete coverage of the search space. For more information, see https://github.com/optuna/optuna/issues/5780.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.PartialFixedSampler","page":"API Reference","title":"Optuna.PartialFixedSampler","text":"PartialFixedSampler(\n    fixed_params::Dict{String,Any}, \n    base_sampler::BaseSampler)\n\nSampler with partially fixed parameters. For further information see the PartialFixedSampler in the Optuna python documentation.\n\nArguments\n\nfixed_params::Dict{String,Any}: A dictionary of parameters to be fixed.\nbase_sampler::BaseSampler: A sampler which samples unfixed parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.MedianPruner","page":"API Reference","title":"Optuna.MedianPruner","text":"MedianPruner(\n    n_startup_trials::Int=5,\n    n_warmup_steps::Int=0,\n    interval_steps::Int=1;\n    n_min_trials::Int=1)\n\nPruner using the median stopping rule. Prune if the trial's best intermediate result is worse than median of intermediate results of previous trials at the same step. For further information see the MedianPruner in the Optuna python documentation.\n\nArguments\n\nn_startup_trials::Int=5: Pruning is disabled until the given number of trials finish in the same study.\nn_warmup_steps::Int=0: Pruning is disabled until the trial exceeds the given number of step. Note that this feature assumes that step starts at zero.\ninterval_steps::Int=1: Interval in number of steps between the pruning checks, offset by the warmup steps. If no value has been reported at the time of a pruning check, that particular check will be postponed until a value is reported.\nn_min_trials::Int=1: Minimum number of reported trial results at a step to judge whether to prune. If the number of reported intermediate values from all trials at the current step is less than n_min_trials, the trial will not be pruned.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.NopPruner","page":"API Reference","title":"Optuna.NopPruner","text":"NopPruner()\n\nPruner which never prunes trials. For further information see the NopPruner in the Optuna python documentation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.PatientPruner","page":"API Reference","title":"Optuna.PatientPruner","text":"PatientPruner(\n    wrapped_pruner::Union{BasePruner,Nothing},\n    patience::Int;\n    min_delta::Float64=0.0)\n\nPruner which wraps another pruner with tolerance. This pruner monitors intermediate values in a trial and prunes the trial if the improvement in the intermediate values after a patience period is less than a threshold. For further information see the PatientPruner in the Optuna python documentation.\n\nArguments\n\nwrapped_pruner::Union{BasePruner,Nothing}: Wrapped pruner to perform pruning when PatientPruner allows a trial to be pruned. If it is nothing, this pruner is equivalent to early-stopping taken the intermediate values in the individual trial.\npatience::Int: Pruning is disabled until the objective doesn't improve for patience consecutive steps.\nmin_delta::Float64=0.0: Tolerance value to check whether or not the objective improves. This value should be non-negative.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.PercentilePruner","page":"API Reference","title":"Optuna.PercentilePruner","text":"PercentilePruner(\n    percentile::Float64,\n    n_startup_trials::Int=5,\n    n_warmup_steps::Int=0,\n    interval_steps::Int=1;\n    n_min_trials::Int=1)\n\nPruner to keep the specified percentile of the trials. Prune if the best intermediate value is in the bottom percentile among trials at the same step. For further information see the PercentilePruner in the Optuna python documentation.\n\nArguments\n\npercentile::Float64: Percentile which must be between 0 and 100 inclusive (e.g., When given 25.0, top of 25th percentile trials are kept).\nn_startup_trials::Int=5: Pruning is disabled until the given number of trials finish in the same study.\nn_warmup_steps::Int=0: Pruning is disabled until the trial exceeds the given number of step. Note that this feature assumes that step starts at zero.\ninterval_steps::Int=1: Interval in number of steps between the pruning checks, offset by the warmup steps. If no value has been reported at the time of a pruning check, that particular check will be postponed until a value is reported. Value must be at least 1.\nn_min_trials::Int=1: Minimum number of reported trial results at a step to judge whether to prune. If the number of reported intermediate values from all trials at the current step is less than n_min_trials, the trial will not be pruned.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.SuccessiveHalvingPruner","page":"API Reference","title":"Optuna.SuccessiveHalvingPruner","text":"SuccessiveHalvingPruner(;\n    min_resource::Union{String,Int}=\"auto\",\n    reduction_factor::Int=4,\n    min_early_stopping_rate::Int=0,\n    bootstrap_count::Int=0)\n\nPruner using Asynchronous Successive Halving Algorithm. For further information see the SuccessiveHalvingPruner in the Optuna python documentation.\n\nKeyword Arguments\n\nmin_resource::Union{String,Int}=\"auto\": A parameter for specifying the minimum resource allocated to a trial (in the paper this parameter is referred to as r). This parameter defaults to \"auto\" where the value is determined based on a heuristic that looks at the number of required steps for the first trial to complete.\nreduction_factor::Int=4: A parameter for specifying reduction factor of promotable trials (in the paper this parameter is referred to as η). At the completion point of each rung, about 1/reduction_factor trials will be promoted.\nmin_early_stopping_rate::Int=0: A parameter for specifying the minimum early-stopping rate (in the paper this parameter is referred to as s).\nbootstrap_count::Int=0: Minimum number of trials that need to complete a rung before any trial is considered for promotion into the next rung.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.HyperbandPruner","page":"API Reference","title":"Optuna.HyperbandPruner","text":"HyperbandPruner(;\n    min_resource::Int=1,\n    max_resource::Union{String,Int}=\"auto\",\n    reduction_factor::Int=3,\n    bootstrap_count::Int=0)\n\nPruner using Hyperband. For further information see the HyperbandPruner in the Optuna python documentation.\n\nKeyword Arguments\n\nmin_resource::Int=1: A parameter for specifying the minimum resource allocated to a trial noted as r in the paper. A smaller r will give a result faster, but a larger r will give a better guarantee of successful judging between configurations.\nmax_resource::Union{String,Int}=\"auto\": A parameter for specifying the maximum resource allocated to a trial. This value represents and should match the maximum iteration steps (e.g., the number of epochs for neural networks). When this argument is \"auto\", the maximum resource is estimated according to the completed trials.\nreduction_factor::Int=3: A parameter for specifying reduction factor of promotable trials noted as η in the paper.\nbootstrap_count::Int=0: Parameter specifying the number of trials required in a rung before any trial can be promoted. Incompatible with max_resource=\"auto\".\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.ThresholdPruner","page":"API Reference","title":"Optuna.ThresholdPruner","text":"ThresholdPruner(;\n    lower::Union{Float64,Nothing}=nothing,\n    upper::Union{Float64,Nothing}=nothing,\n    n_warmup_steps::Int=0,\n    interval_steps::Int=1)\n\nPruner to detect outlying metrics of the trials. Prune if a metric exceeds upper threshold, falls behind lower threshold or reaches NaN. For further information see the ThresholdPruner in the Optuna python documentation.\n\nKeyword Arguments\n\nlower::Union{Float64,Nothing}=nothing: A minimum value which determines whether pruner prunes or not. If an intermediate value is smaller than lower, it prunes.\nupper::Union{Float64,Nothing}=nothing: A maximum value which determines whether pruner prunes or not. If an intermediate value is larger than upper, it prunes.\nn_warmup_steps::Int=0: Pruning is disabled if the step is less than the given number of warmup steps.\ninterval_steps::Int=1: Interval in number of steps between the pruning checks, offset by the warmup steps. If no value has been reported at the time of a pruning check, that particular check will be postponed until a value is reported. Value must be at least 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.WilcoxonPruner","page":"API Reference","title":"Optuna.WilcoxonPruner","text":"WilcoxonPruner(;\n    p_threshold::Float64=0.1,\n    n_startup_steps::Int=2)\n\nPruner based on the Wilcoxon signed-rank test. This pruner performs the Wilcoxon signed-rank test between the current trial and the current best trial, and stops whenever the pruner is sure up to a given p-value that the current trial is worse than the best one. For further information see the WilcoxonPruner in the Optuna python documentation.\n\nKeyword Arguments\n\np_threshold::Float64=0.1: The p-value threshold for pruning. This value should be between 0 and 1. A trial will be pruned whenever the pruner is sure up to the given p-value that the current trial is worse than the best trial. The larger this value is, the more aggressive pruning will be performed.\nn_startup_steps::Int=2: The number of steps before which no trials are pruned. Pruning starts only after you have nstartupsteps steps of available observations for comparison between the current trial and the best trial.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.UniformCrossover","page":"API Reference","title":"Optuna.UniformCrossover","text":"UniformCrossover(\n    swapping_prob::Float64=0.5\n)\n\nSelect each parameter with equal probability from the two parent individuals.  For further information see the UniformCrossover in the Optuna python documentation.\n\nArguments\n\nswapping_prob::Float64=0.5: Probability of swapping each parameter of the parents during crossover.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.BLXAlphaCrossover","page":"API Reference","title":"Optuna.BLXAlphaCrossover","text":"BLXAlphaCrossover(\n    alpha::Float64=0.5\n)\n\nUniformly samples child individuals from the hyper-rectangles created by the two parent individuals. For further information see the BLXAlphaCrossover in the Optuna python documentation.\n\nArguments\n\nalpha::Float64=0.5: Parametrizes blend operation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.SPXCrossover","page":"API Reference","title":"Optuna.SPXCrossover","text":"SPXCrossover(\n    epsilon::Union{Nothing,Float64}=nothing\n)\n\nUniformly samples child individuals from within a single simplex that is similar to the simplex produced by the parent individual. For further information see the SPXCrossover in the Optuna python documentation.\n\nArguments\n\nepsilon::Union{Nothing,Float64}=nothing: Expansion rate. If not specified, defaults to sqrt(len(search_space) + 2).\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.SBXCrossover","page":"API Reference","title":"Optuna.SBXCrossover","text":"SBXCrossover(\n    eta::Union{Nothing,Float64}=nothing,\n    uniform_crossover_prob::Float64=0.5,\n    use_child_gene_prob::Float64=0.5,\n)\n\nUniformly samples child individuals from within a single simplex that is similar to the simplex produced by the parent individual. For further information see the SBXCrossover in the Optuna python documentation.\n\nArguments\n\neta::Union{Nothing,Float64}=nothing: Distribution index. A small value of eta allows distant solutions to be selected as children solutions. If not specified, takes default value of 2 for single objective functions and 20 for multi objective.\nuniform_crossover_prob::Float64=0.5: uniform_crossover_prob is the probability of uniform crossover between two individuals selected as candidate child individuals. This argument is whether or not two individuals are crossover to make one child individual. If the uniform_crossover_prob exceeds 0.5, the result is equivalent to 1-uniform_crossover_prob, because it returns one of the two individuals of the crossover result. If not specified, takes default value of 0.5. The range of values is [0.0, 1.0].\nuse_child_gene_prob::Float64=0.5: use_child_gene_prob is the probability of using the value of the generated child variable rather than the value of the parent. This probability is applied to each variable individually. where 1-use_child_gene_prob is the probability of using the parent’s values as it is. If not specified, takes default value of 0.5. The range of values is (0.0, 1.0].\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.VSBXCrossover","page":"API Reference","title":"Optuna.VSBXCrossover","text":"VSBXCrossover(\n    eta::Union{Nothing,Float64}=nothing,\n    uniform_crossover_prob::Float64=0.5,\n    use_child_gene_prob::Float64=0.5,\n)\n\nvSBX generates child individuals without excluding any region of the parameter space, while maintaining the excellent properties of SBX. For further information see the VSBXCrossover in the Optuna python documentation.\n\nArguments\n\neta::Union{Nothing,Float64}=nothing: Distribution index. A small value of eta allows distant solutions to be selected as children solutions. If not specified, takes default value of 2 for single objective functions and 20 for multi objective.\nuniform_crossover_prob::Float64=0.5: uniform_crossover_prob is the probability of uniform crossover between two individuals selected as candidate child individuals. This argument is whether or not two individuals are crossover to make one child individual. If the uniform_crossover_prob exceeds 0.5, the result is equivalent to 1-uniform_crossover_prob, because it returns one of the two individuals of the crossover result. If not specified, takes default value of 0.5. The range of values is [0.0, 1.0].\nuse_child_gene_prob::Float64=0.5: use_child_gene_prob is the probability of using the value of the generated child variable rather than the value of the parent. This probability is applied to each variable individually. where 1-use_child_gene_prob is the probability of using the parent’s values as it is. If not specified, takes default value of 0.5. The range of values is (0.0, 1.0].\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.UNDXCrossover","page":"API Reference","title":"Optuna.UNDXCrossover","text":"UNDXCrossover(\n    sigma_xi::Float64=0.5, \n    sigma_eta::Union{Nothing,Float64}=nothing\n)\n\nGenerates child individuals from the three parents using a multivariate normal distribution. For further information see the UNDXCrossover in the Optuna python documentation.\n\nArguments\n\nsigma_xi::Float64=0.5: Parametrizes normal distribution from which xi is drawn.\nsigma_eta::Union{Nothing,Float64}=nothing: Parametrizes normal distribution from which etas are drawn. If not specified, defaults to 0.35 / sqrt(len(search_space)).\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.Study","page":"API Reference","title":"Optuna.Study","text":"Study(\n    study, \n    artifact_store, \n    storage\n)\n\nThis data structure represents an Optuna study and its corresponding artifact and data storage. A study is a collection of trials that share the same optimization objective.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.load_study","page":"API Reference","title":"Optuna.load_study","text":"load_study(\n    study_name::String,\n    storage::BaseStorage,\n    artifact_store::BaseArtifactStore;\n    sampler::Union{Nothing,BaseSampler}=nothing,\n    pruner::Union{Nothing,BasePruner}=nothing,\n)\n\nLoad an existing study with the given name, artifact store, storage, sampler and pruner. For further information see the load_study in the Optuna python documentation.\n\nArguments\n\nstudy_name::String: Name of the study.\nstorage::BaseStorage: Storage of the study. (see Storage)\nartifact_store::BaseArtifactStore: Artifact store for the study. (see Artifacts)\n\nKeyword Arguments\n\nsampler::Union{Nothing,BaseSampler}=nothing: Sampler to use for the study. (see Sampler)\npruner::Union{Nothing,BasePruner}=nothing: Pruner to use for the study. (see Pruner)\n\nReturns\n\nStudy: The loaded study. (see Study)\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.delete_study","page":"API Reference","title":"Optuna.delete_study","text":"delete_study(\n    study_name::String,\n    storage::BaseStorage,\n)\n\nDelete a study with the given name and storage backend. For further information see the delete_study in the Optuna python documentation.\n\nArguments\n\nstudy_name::String: Name of the study.\nstorage::BaseStorage: Storage of the study. (see Storage)\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.copy_study","page":"API Reference","title":"Optuna.copy_study","text":"copy_study(\n    from_study_name::String,\n    from_storage::BaseStorage,\n    to_storage::BaseStorage,\n    to_study_name::String=\"\",\n)\n\nCopy a study from one storage backend to another. For further information see the copy_study in the Optuna python documentation.\n\nArguments\n\nfrom_study_name::String: Name of the study to copy.\nfrom_storage::BaseStorage: Storage backend to copy the study from. (see Storage)\nto_storage::BaseStorage: Storage backend to copy the study to. (see Storage)\nto_study_name::String=\"\": Name of the new study. If empty, the original study name is used.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.ask","page":"API Reference","title":"Optuna.ask","text":"ask(\n    study::Study; \n    multithreading::Bool=Threads.nthreads() > 1\n)\n\nWrapper for the Optuna ask function. For further information see the ask in the Optuna python documentation.\n\nThis function is safe for multithreading.\n\nArguments\n\nstudy::Study: The study to ask the trial from. (see Study)\n\nKeywords\n\nmultithreading::Bool=Threads.nthreads() > 1 if multithreading is used, default is automatically detected (true if more than one thread is available)\n\nReturns\n\nTrial: The new trial. (see Trial)\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.tell","page":"API Reference","title":"Optuna.tell","text":"tell(\n    study::Study,\n    trial::Trial{false},\n    score::Union{Nothing,T,Vector{T}}=nothing;\n    prune::Bool=false,\n\n) where {T<:AbstractFloat}\n\nTell the study about the result of a trial. This is the proper way to complete a trial created with the ask function. For further information see the tell in the Optuna python documentation.\n\nArguments\n\nstudy::Study: The study to report the trial to. (see Study)\ntrial::Trial: The trial which was completed. (see Trial)\nscore::Union{Nothing,T,Vector{T}}=nothing: The score of the trial. If nothing, the trial is pruned.\nprune::Bool=false: If true, the trial is pruned.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.best_trial","page":"API Reference","title":"Optuna.best_trial","text":"best_trial(\n    study::Study\n)\n\nGet the best trial of the study. For further information see the best_trial in the Optuna python documentation.\n\nArguments\n\nstudy::Study: The study to get the best trial from. (see Study)\n\nReturns\n\nTrial: The best trial. (see Trial)\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.best_params","page":"API Reference","title":"Optuna.best_params","text":"best_params(\n    study::Study\n)\n\nGet the best parameters of the study. For further information see the best_params in the Optuna python documentation.\n\nArguments\n\nstudy::Study: The study to get the best parameters from. (see Study)\n\nReturns\n\nDict{String,Any}: The best parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.best_value","page":"API Reference","title":"Optuna.best_value","text":"best_value(\n    study::Study\n)\n\nGet the best objective value of the study. For further information see the best_value in the Optuna python documentation.\n\nArguments\n\nstudy::Study: The study to get the best objective value from. (see Study)\n\nReturns\n\nFloat64: The best objective value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.upload_artifact","page":"API Reference","title":"Optuna.upload_artifact","text":"upload_artifact(\n    study::Study, \n    trial::Trial, \n    data::Dict\n)\n\nUpload an artifact for a given trial in the study. The artifact is a .jld2 file containing the provided data. For further information see the upload_artifact in the Optuna python documentation.\n\nArguments\n\nstudy::Study: The study to upload the artifact to. (see Study)\ntrial::Trial: The trial to associate the artifact with. (see Trial)\ndata::Dict: The data to be stored as an artifact.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.get_all_artifact_meta","page":"API Reference","title":"Optuna.get_all_artifact_meta","text":"get_all_artifact_meta(\n    study::Study\n)\n\nGet all artifact metadata for all trials in the given study. For further information see the getallartifact_meta in the Optuna python documentation.\n\nArguments\n\nstudy::Study: The study to get the artifact metadata from. (see Study)\n\nReturns\n\nVector{ArtifactMeta}: List of artifact metadata of all artifacts in the study.\n\n\n\n\n\nget_all_artifact_meta(\n    study::Study, \n    trial\n)\n\nGet all artifact metadata for the trial in the given study. For further information see the getallartifact_meta in the Optuna python documentation.\n\nArguments\n\nstudy::Study: The study to get the artifact metadata from. (see Study)\ntrial: The trial to get the artifact metadata from. (see Trial)\n\nReturns\n\nVector{ArtifactMeta}: List of artifact metadata of the given trial.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.download_artifact","page":"API Reference","title":"Optuna.download_artifact","text":"download_artifact(\n    study::Study, \n    artifact_id::String, \n    file_path::String\n)\n\nDownload an artifact from a given study identified by its artifactid and the filepath where it should be stored. For further information see the download_artifact in the Optuna python documentation.\n\nArguments\n\nstudy::Study: The study to download the artifact from. (see Study)\nartifact_id::String: The ID of the artifact to download.\nfile_path::String: The path where the downloaded artifact should be stored.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.Trial","page":"API Reference","title":"Optuna.Trial","text":"Trial(\n    trial, \n    multithreading::Bool=false\n)\n\nTrial is a data structure wrapper for an Optuna trial.\n\n\n\n\n\n","category":"type"},{"location":"api/#Optuna.suggest_int","page":"API Reference","title":"Optuna.suggest_int","text":"suggest_int(\n    trial::Trial, \n    name::String, \n    low::T, \n    high::T;\n    step::T=1, \n    log::Bool=false\n) where {T<:Signed}\n\nSuggest an integer value for the given parameter name within the specified range. For further information see the suggest_int in the Optuna python documentation.\n\nArguments\n\ntrial::Trial: The trial to suggest the parameter for. (see Trial)\nname::String: The name of the parameter to suggest.\nlow::T: The lower bound of the range (inclusive).\nhigh::T: The upper bound of the range (inclusive).\n\nKeyword Arguments\n\nstep::T=1: The step size for the range. The suggested value will be a multiple of step away from low.\nlog::Bool=false: If true, the range will be sampled on a logarithmic scale. (\n\nReturns\n\nT: Suggested integer value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.suggest_float","page":"API Reference","title":"Optuna.suggest_float","text":"suggest_float(\n    trial::Trial,\n    name::String,\n    low::T,\n    high::T;\n    step::Union{Nothing,T}=nothing,\n    log::Bool=false,\n) where {T<:AbstractFloat}\n\nSuggest a float value for the given parameter name within the specified range. For further information see the suggest_float in the Optuna python documentation.\n\nArguments\n\ntrial::Trial: The trial to suggest the parameter for. (see Trial)\nname::String: The name of the parameter to suggest.\nlow::T: The lower bound of the range (inclusive).\nhigh::T: The upper bound of the range (inclusive).\n\nKeyword Arguments\n\nstep::Union{Nothing,T}=nothing: A step of discretization.\nlog::Bool=false: If true, the range will be sampled on a logarithmic scale. (\n\nReturns\n\nFloat64: Suggested float value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.suggest_categorical","page":"API Reference","title":"Optuna.suggest_categorical","text":"suggest_categorical(\n    trial::Trial, \n    name::String, \n    choices::Vector{T}\n) where {T<:Union{Bool,Int,AbstractFloat,String}}\n\nSuggest a categorical value for the given parameter name from the specified choices. For further information see the suggest_categorical in the Optuna python documentation.\n\nArguments\n\ntrial::Trial: The trial to suggest the parameter for. (see Trial)\nname::String: The name of the parameter to suggest.\nchoices::Vector{T}: The choices to suggest from.\n\nReturns\n\nT: Suggested categorical value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.report","page":"API Reference","title":"Optuna.report","text":"report(\n    trial::Trial, \n    value::AbstractFloat, \n    step::Int\n)\n\nReport an intermediate value for the given trial at a specific step. For further information see the report in the Optuna python documentation.\n\nArguments\n\ntrial::Trial: The trial to report the value for. (see Trial)\nvalue::AbstractFloat: The intermediate value to report.\nstep::Int: The step at which the value is reported.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.should_prune","page":"API Reference","title":"Optuna.should_prune","text":"should_prune(\n    trial::Trial\n)\n\nCheck if the given trial should be pruned based on the pruner's decision. For further information see the should_prune in the Optuna python documentation.\n\nArguments\n\ntrial::Trial: The trial to check for pruning. (see Trial)\n\nReturns\n\nBool: true if the trial should be pruned, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.optimize","page":"API Reference","title":"Optuna.optimize","text":"optimize(\n    study::Study, \n    objective::Function, \n    params::NamedTuple; \n    n_trials::Int=100,\n    verbose::Bool=false,\n    n_jobs::Integer=1,\n)\n\nOptimize function that checks if the optimization should be performed in a single-threaded or multi-threaded way based on the keyword argument n_jobs and calls the corresponding function.\n\nUses the sampler of the study which implements the task of value suggestion based on a specified distribution. For the available samplers see Sampler.\n\nIf the objective function returns nothing, the trial is pruned.\n\nArguments\n\nstudy::Study: Study that should be optimized.\nobjective::Function: Function that takes a trial and returns a score.\nparams::NamedTuple: Named tuple of parameters to optimize.\n\nKeyword Arguments\n\nn_trials::Int=100: Number of trials to run.\nverbose::Bool=false: If true, print information about the optimization process.\nn_jobs::Integer=1: Number of threads to use for optimization. If n_jobs > 1, multithreading is used. Note that the number of threads allocated for the process must be greater than or equal to n_jobs and exactly one interactive thread must be allocated for multithreading to work. You can start Julia with n threads and an interactive thread by setting the environment variable JULIA_NUM_THREADS=n,1 or start the Julia REPL with -t n,1.\n\nReturns\n\nStudy: The optimized study. Study\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.is_conda_pkg_installed","page":"API Reference","title":"Optuna.is_conda_pkg_installed","text":"is_conda_pkg_installed(\n    pkg_name::String; \n    version::Union{Nothing,String}=nothing\n)\n\nTest if the given package with the given version is installed in the conda environment.\n\nArguments\n\npkg_name::String: Name of the package.\n\nKeyword Arguments\n\nversion::Union{Nothing,String}=nothing: Version of the package.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optuna.add_conda_pkg","page":"API Reference","title":"Optuna.add_conda_pkg","text":"add_conda_pkg(\n    pkg_name::String; \n    version::Union{Nothing,String}=nothing\n)\n\nAdds the given package with the given version in the conda environment if it is not installed.\n\nArguments\n\npkg_name::String: Name of the package.\n\nKeyword Arguments\n\nversion::Union{Nothing,String}=nothing: Version of the package.\n\n\n\n\n\n","category":"function"},{"location":"#Optuna.jl","page":"Home","title":"Optuna.jl","text":"(Image: Docs) (Image: Build Status) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: Code Style: Blue) (Image: Coverage) \n\nOptuna.jl is a software package for the Julia programming language that provides an API Interface for the open source hyperparameter optimization framework Optuna.\n\nThis package is based on the Python API that is provided by Preferred Networks, Inc. in their GitHub repository.\n\n“Optuna, the Optuna logo and any related marks are trademarks of Preferred Networks, Inc.”","category":"section"},{"location":"#How-to-install-Optuna.jl","page":"Home","title":"How to install Optuna.jl","text":"Open the Jula REPL. Type ] to open the package manager.\nInstall Optuna\n\n    pkg> add Optuna\n\nExamples for hyperparameter optimization are provided in the examples folder. You can also refer to the documentation for further information.","category":"section"},{"location":"#How-to-use-Optuna.jl","page":"Home","title":"How to use Optuna.jl","text":"The purest way to set up a hyperparameter optimization is shown in the following. For more advanced topics - like storing artifacts, multithreading, and more - see the examples folder.\n\nusing Optuna\n\n# central database storage for all studies\ndatabase_url = \"examples/storage\"\ndatabase_name = \"example_db\"\n\n# name and artifact path for the study\nstudy_name = \"example-study\"\nartifact_path = \"examples/artifacts\"\n\n# Create/Load database storage for studies\nstorage_url = create_sqlite_url(database_url, database_name)\nstorage = RDBStorage(storage_url)\n\n# Create artifact store for the study\nartifact_store = FileSystemArtifactStore(artifact_path)\n\nstudy = Study(\n    study_name,\n    artifact_store,\n    storage;\n    direction=\"minimize\",\n    load_if_exists=true,\n)\n\nfunction objective(trial::Trial; x, y, z)\n    result = z ? x * (y - param) : x * (y + param)\n    return result\nend\n\noptimize(study, objective, (x=[0, 100], y=[-10.0f0, 10.0f0], z=[true, false]); n_trials=10, n_jobs=1, verbose=true)\n\nprintln(\"Best params: \", best_params(study))\nprintln(\"Best value: \", best_value(study))","category":"section"},{"location":"#How-to-contribute","page":"Home","title":"How to contribute","text":"Contributors are welcome. Before contributing, please read, understand and follow the Contributor's Guide on Collaborative Practices for Community Packages.","category":"section"}]
}
